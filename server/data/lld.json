[
  {
    "title": "Singleton Design Pattern",
    "slug": "singleton-pattern",
    "category": "Design Pattern",
    "intent": "## Intent\n\nThe Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance. This is useful when exactly one object is needed to coordinate actions across the system.\n\n## Problem\n\n- Need to ensure only one instance of a class exists\n- Global access point required\n- Lazy initialization needed\n- Thread safety concerns\n\n## Solution\n\n- Make the constructor private\n- Create a static method to get the instance\n- Ensure thread safety\n- Handle lazy initialization properly\n\n## Use Cases\n\n- Database connections\n- Logger instances\n- Configuration managers\n- Cache managers\n- Thread pools",
    "structure": "## Class Diagram\n\n```\n┌─────────────────┐\n│    Singleton    │\n├─────────────────┤\n│ - instance      │\n├─────────────────┤\n│ - Singleton()   │\n│ + getInstance() │\n└─────────────────┘\n```\n\n## Key Components\n\n1. **Private Constructor:** Prevents direct instantiation\n2. **Static Instance Variable:** Holds the single instance\n3. **Static Getter Method:** Provides access to the instance\n4. **Thread Safety:** Ensures safe concurrent access\n\n## Implementation Considerations\n\n### Thread Safety Options\n- **Eager Initialization:** Create instance at class loading\n- **Lazy Initialization:** Create instance when first requested\n- **Double-Checked Locking:** Optimize lazy initialization\n- **Enum Singleton:** Use enum for thread-safe singleton\n\n### Memory Management\n- **Static Instance:** Lives for application lifetime\n- **Memory Leaks:** Be careful with references\n- **Garbage Collection:** May not be collected\n\n### Testing Challenges\n- **Global State:** Makes testing difficult\n- **Dependency Injection:** Consider alternatives\n- **Mocking:** Hard to mock singleton instances",
    "useCases": "## Real-World Applications\n\n### 1. Database Connection Pool\n```cpp\nclass DatabaseManager {\nprivate:\n    static DatabaseManager* instance;\n    DatabaseManager() { /* Initialize connection pool */ }\n\npublic:\n    static DatabaseManager* getInstance() {\n        if (!instance) {\n            instance = new DatabaseManager();\n        }\n        return instance;\n    }\n};\n```\n\n### 2. Logger System\n```cpp\nclass Logger {\nprivate:\n    static Logger* instance;\n    Logger() { /* Initialize logging */ }\n\npublic:\n    static Logger* getInstance() {\n        if (!instance) {\n            instance = new Logger();\n        }\n        return instance;\n    }\n    \n    void log(const string& message) {\n        // Logging implementation\n    }\n};\n```\n\n### 3. Configuration Manager\n```cpp\nclass ConfigManager {\nprivate:\n    static ConfigManager* instance;\n    map<string, string> config;\n    ConfigManager() { loadConfig(); }\n\npublic:\n    static ConfigManager* getInstance() {\n        if (!instance) {\n            instance = new ConfigManager();\n        }\n        return instance;\n    }\n    \n    string getValue(const string& key) {\n        return config[key];\n    }\n};\n```\n\n### 4. Cache Manager\n```cpp\nclass CacheManager {\nprivate:\n    static CacheManager* instance;\n    unordered_map<string, string> cache;\n    CacheManager() { /* Initialize cache */ }\n\npublic:\n    static CacheManager* getInstance() {\n        if (!instance) {\n            instance = new CacheManager();\n        }\n        return instance;\n    }\n    \n    void put(const string& key, const string& value) {\n        cache[key] = value;\n    }\n    \n    string get(const string& key) {\n        return cache[key];\n    }\n};\n```\n\n## When to Use Singleton\n\n### Appropriate Use Cases\n- **Resource Management:** Database connections, file handles\n- **Configuration:** Global application settings\n- **Logging:** Centralized logging system\n- **Caching:** Global cache management\n- **Hardware Access:** Printer spooler, graphics card\n\n### When NOT to Use\n- **Stateful Objects:** Objects that change frequently\n- **Testability:** When you need to mock dependencies\n- **Flexibility:** When you might need multiple instances\n- **Performance:** When lazy initialization is expensive\n\n## Anti-Patterns\n\n### Common Mistakes\n- **Overuse:** Using singleton for everything\n- **Thread Safety:** Not handling concurrent access\n- **Testing:** Making code hard to test\n- **Dependencies:** Creating tight coupling\n- **Memory Leaks:** Not managing instance lifecycle\n\n### Better Alternatives\n- **Dependency Injection:** Pass dependencies explicitly\n- **Factory Pattern:** Create objects as needed\n- **Service Locator:** Find services by name\n- **Static Classes:** For stateless operations",
    "cppExample": "#include <iostream>\n#include <mutex>\n#include <memory>\n\nusing namespace std;\n\nclass Singleton {\nprivate:\n    // Private constructor to prevent direct instantiation\n    Singleton() {\n        cout << \"Singleton instance created\" << endl;\n    }\n    \n    // Delete copy constructor and assignment operator\n    Singleton(const Singleton&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n    \n    // Static instance variable\n    static unique_ptr<Singleton> instance;\n    static mutex mtx;\n\npublic:\n    // Static method to get the instance\n    static Singleton* getInstance() {\n        // Double-checked locking for thread safety\n        if (!instance) {\n            lock_guard<mutex> lock(mtx);\n            if (!instance) {\n                instance = make_unique<Singleton>();\n            }\n        }\n        return instance.get();\n    }\n    \n    // Example method\n    void doSomething() {\n        cout << \"Singleton is doing something...\" << endl;\n    }\n    \n    // Destructor\n    ~Singleton() {\n        cout << \"Singleton instance destroyed\" << endl;\n    }\n};\n\n// Static member definitions\nunique_ptr<Singleton> Singleton::instance = nullptr;\nmutex Singleton::mtx;\n\n// Alternative: Thread-safe lazy initialization using std::call_once\nclass ThreadSafeSingleton {\nprivate:\n    ThreadSafeSingleton() {\n        cout << \"Thread-safe singleton created\" << endl;\n    }\n    \n    static unique_ptr<ThreadSafeSingleton> instance;\n    static once_flag init_flag;\n\npublic:\n    static ThreadSafeSingleton* getInstance() {\n        call_once(init_flag, []() {\n            instance = make_unique<ThreadSafeSingleton>();\n        });\n        return instance.get();\n    }\n    \n    void doSomething() {\n        cout << \"Thread-safe singleton is working...\" << endl;\n    }\n};\n\n// Static member definitions\nunique_ptr<ThreadSafeSingleton> ThreadSafeSingleton::instance = nullptr;\nonce_flag ThreadSafeSingleton::init_flag;\n\n// Example usage\nint main() {\n    cout << \"=== Singleton Pattern Demo ===\" << endl;\n    \n    // Get singleton instances\n    Singleton* s1 = Singleton::getInstance();\n    Singleton* s2 = Singleton::getInstance();\n    \n    // Verify they are the same instance\n    cout << \"s1 == s2: \" << (s1 == s2 ? \"true\" : \"false\") << endl;\n    \n    // Use the singleton\n    s1->doSomething();\n    \n    // Thread-safe singleton\n    ThreadSafeSingleton* ts1 = ThreadSafeSingleton::getInstance();\n    ThreadSafeSingleton* ts2 = ThreadSafeSingleton::getInstance();\n    \n    cout << \"ts1 == ts2: \" << (ts1 == ts2 ? \"true\" : \"false\") << endl;\n    ts1->doSomething();\n    \n    return 0;\n}\n\n/*\nOutput:\n=== Singleton Pattern Demo ===\nSingleton instance created\ns1 == s2: true\nSingleton is doing something...\nThread-safe singleton created\nts1 == ts2: true\nThread-safe singleton is working...\nSingleton instance destroyed\nThread-safe singleton destroyed\n*/"
  },
  {
    "title": "Factory Design Pattern",
    "slug": "factory-pattern",
    "category": "Design Pattern",
    "intent": "## Intent\n\nThe Factory pattern provides an interface for creating objects without specifying their exact class. It encapsulates object creation logic and provides a way to create objects based on some criteria.\n\n## Problem\n\n- Need to create objects without knowing their exact types\n- Object creation logic is complex\n- Want to decouple object creation from usage\n- Need to support multiple product types\n\n## Solution\n\n- Define an interface for creating objects\n- Let subclasses decide which class to instantiate\n- Encapsulate object creation logic\n- Provide a common interface for all products\n\n## Use Cases\n\n- Database drivers\n- UI components\n- File parsers\n- Payment processors\n- Shape creators",
    "structure": "## Class Diagram\n\n```\n┌─────────────────┐\n│    Product      │\n├─────────────────┤\n│ + operation()   │\n└─────────────────┘\n         ^\n         |\n┌─────────────────┐\n│  ConcreteProduct│\n├─────────────────┤\n│ + operation()   │\n└─────────────────┘\n         ^\n         |\n┌─────────────────┐\n│    Creator      │\n├─────────────────┤\n│ + factoryMethod()│\n└─────────────────┘\n         ^\n         |\n┌─────────────────┐\n│ ConcreteCreator │\n├─────────────────┤\n│ + factoryMethod()│\n└─────────────────┘\n```\n\n## Key Components\n\n1. **Product Interface:** Common interface for all products\n2. **Concrete Products:** Specific implementations\n3. **Creator Interface:** Factory method interface\n4. **Concrete Creator:** Specific factory implementations\n\n## Factory Types\n\n### 1. Simple Factory\n- Single factory class\n- Creates different products based on parameters\n- Simple but violates Open/Closed Principle\n\n### 2. Factory Method\n- Abstract creator with factory method\n- Each concrete creator creates specific products\n- Follows Open/Closed Principle\n\n### 3. Abstract Factory\n- Creates families of related products\n- Multiple factory methods\n- More complex but more flexible",
    "useCases": "## Real-World Applications\n\n### 1. Database Connection Factory\n```cpp\nclass DatabaseConnection {\npublic:\n    virtual void connect() = 0;\n    virtual void disconnect() = 0;\n};\n\nclass MySQLConnection : public DatabaseConnection {\npublic:\n    void connect() override {\n        cout << \"Connecting to MySQL...\" << endl;\n    }\n    void disconnect() override {\n        cout << \"Disconnecting from MySQL...\" << endl;\n    }\n};\n\nclass PostgreSQLConnection : public DatabaseConnection {\npublic:\n    void connect() override {\n        cout << \"Connecting to PostgreSQL...\" << endl;\n    }\n    void disconnect() override {\n        cout << \"Disconnecting from PostgreSQL...\" << endl;\n    }\n};\n\nclass DatabaseFactory {\npublic:\n    static unique_ptr<DatabaseConnection> createConnection(const string& type) {\n        if (type == \"mysql\") {\n            return make_unique<MySQLConnection>();\n        } else if (type == \"postgresql\") {\n            return make_unique<PostgreSQLConnection>();\n        }\n        return nullptr;\n    }\n};\n```\n\n### 2. Shape Factory\n```cpp\nclass Shape {\npublic:\n    virtual void draw() = 0;\n    virtual double area() = 0;\n};\n\nclass Circle : public Shape {\nprivate:\n    double radius;\npublic:\n    Circle(double r) : radius(r) {}\n    void draw() override {\n        cout << \"Drawing a circle with radius \" << radius << endl;\n    }\n    double area() override {\n        return 3.14159 * radius * radius;\n    }\n};\n\nclass Rectangle : public Shape {\nprivate:\n    double width, height;\npublic:\n    Rectangle(double w, double h) : width(w), height(h) {}\n    void draw() override {\n        cout << \"Drawing a rectangle \" << width << \"x\" << height << endl;\n    }\n    double area() override {\n        return width * height;\n    }\n};\n\nclass ShapeFactory {\npublic:\n    static unique_ptr<Shape> createShape(const string& type, const vector<double>& params) {\n        if (type == \"circle\" && params.size() >= 1) {\n            return make_unique<Circle>(params[0]);\n        } else if (type == \"rectangle\" && params.size() >= 2) {\n            return make_unique<Rectangle>(params[0], params[1]);\n        }\n        return nullptr;\n    }\n};\n```\n\n### 3. Payment Processor Factory\n```cpp\nclass PaymentProcessor {\npublic:\n    virtual bool processPayment(double amount) = 0;\n    virtual string getPaymentMethod() = 0;\n};\n\nclass CreditCardProcessor : public PaymentProcessor {\npublic:\n    bool processPayment(double amount) override {\n        cout << \"Processing credit card payment: $\" << amount << endl;\n        return true;\n    }\n    string getPaymentMethod() override {\n        return \"Credit Card\";\n    }\n};\n\nclass PayPalProcessor : public PaymentProcessor {\npublic:\n    bool processPayment(double amount) override {\n        cout << \"Processing PayPal payment: $\" << amount << endl;\n        return true;\n    }\n    string getPaymentMethod() override {\n        return \"PayPal\";\n    }\n};\n\nclass PaymentFactory {\npublic:\n    static unique_ptr<PaymentProcessor> createProcessor(const string& type) {\n        if (type == \"creditcard\") {\n            return make_unique<CreditCardProcessor>();\n        } else if (type == \"paypal\") {\n            return make_unique<PayPalProcessor>();\n        }\n        return nullptr;\n    }\n};\n```\n\n## When to Use Factory Pattern\n\n### Appropriate Use Cases\n- **Object Creation Complexity:** When object creation is complex\n- **Multiple Product Types:** When you have multiple related products\n- **Runtime Type Selection:** When product type is determined at runtime\n- **Decoupling:** When you want to decouple creation from usage\n- **Configuration-Driven:** When creation depends on configuration\n\n### When NOT to Use\n- **Simple Objects:** When object creation is straightforward\n- **Single Product Type:** When you only have one product type\n- **Compile-Time Types:** When types are known at compile time\n- **Performance Critical:** When factory overhead is significant\n\n## Benefits and Drawbacks\n\n### Benefits\n- **Flexibility:** Easy to add new product types\n- **Decoupling:** Separates creation from usage\n- **Consistency:** Centralized creation logic\n- **Testability:** Easy to mock and test\n- **Maintainability:** Changes in one place\n\n### Drawbacks\n- **Complexity:** Adds extra classes and interfaces\n- **Overhead:** Additional abstraction layer\n- **Over-engineering:** May be overkill for simple cases\n- **Learning Curve:** Requires understanding of inheritance\n\n## Best Practices\n\n### 1. Use Abstract Base Classes\n- Define common interface for all products\n- Ensure consistent behavior\n- Enable polymorphism\n\n### 2. Error Handling\n- Handle invalid product types gracefully\n- Return null or throw exceptions\n- Provide meaningful error messages\n\n### 3. Configuration\n- Use configuration files for product types\n- Make factory behavior configurable\n- Support runtime configuration changes\n\n### 4. Testing\n- Create mock factories for testing\n- Test all product types\n- Verify factory behavior\n\n### 5. Documentation\n- Document all supported product types\n- Provide usage examples\n- Explain creation logic",
    "cppExample": "#include <iostream>\n#include <memory>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Product interface\nclass Vehicle {\npublic:\n    virtual void start() = 0;\n    virtual void stop() = 0;\n    virtual string getType() = 0;\n    virtual ~Vehicle() = default;\n};\n\n// Concrete products\nclass Car : public Vehicle {\nprivate:\n    string model;\npublic:\n    Car(const string& m) : model(m) {}\n    \n    void start() override {\n        cout << \"Starting car: \" << model << endl;\n    }\n    \n    void stop() override {\n        cout << \"Stopping car: \" << model << endl;\n    }\n    \n    string getType() override {\n        return \"Car\";\n    }\n};\n\nclass Motorcycle : public Vehicle {\nprivate:\n    string model;\npublic:\n    Motorcycle(const string& m) : model(m) {}\n    \n    void start() override {\n        cout << \"Starting motorcycle: \" << model << endl;\n    }\n    \n    void stop() override {\n        cout << \"Stopping motorcycle: \" << model << endl;\n    }\n    \n    string getType() override {\n        return \"Motorcycle\";\n    }\n};\n\nclass Truck : public Vehicle {\nprivate:\n    string model;\npublic:\n    Truck(const string& m) : model(m) {}\n    \n    void start() override {\n        cout << \"Starting truck: \" << model << endl;\n    }\n    \n    void stop() override {\n        cout << \"Stopping truck: \" << model << endl;\n    }\n    \n    string getType() override {\n        return \"Truck\";\n    }\n};\n\n// Simple Factory\nclass VehicleFactory {\npublic:\n    static unique_ptr<Vehicle> createVehicle(const string& type, const string& model) {\n        if (type == \"car\") {\n            return make_unique<Car>(model);\n        } else if (type == \"motorcycle\") {\n            return make_unique<Motorcycle>(model);\n        } else if (type == \"truck\") {\n            return make_unique<Truck>(model);\n        } else {\n            cout << \"Unknown vehicle type: \" << type << endl;\n            return nullptr;\n        }\n    }\n};\n\n// Factory Method Pattern\nclass VehicleCreator {\npublic:\n    virtual unique_ptr<Vehicle> createVehicle(const string& model) = 0;\n    virtual ~VehicleCreator() = default;\n};\n\nclass CarCreator : public VehicleCreator {\npublic:\n    unique_ptr<Vehicle> createVehicle(const string& model) override {\n        return make_unique<Car>(model);\n    }\n};\n\nclass MotorcycleCreator : public VehicleCreator {\npublic:\n    unique_ptr<Vehicle> createVehicle(const string& model) override {\n        return make_unique<Motorcycle>(model);\n    }\n};\n\nclass TruckCreator : public VehicleCreator {\npublic:\n    unique_ptr<Vehicle> createVehicle(const string& model) override {\n        return make_unique<Truck>(model);\n    }\n};\n\n// Example usage\nint main() {\n    cout << \"=== Factory Pattern Demo ===\" << endl;\n    \n    // Simple Factory usage\n    cout << \"\\n--- Simple Factory ---\" << endl;\n    auto car = VehicleFactory::createVehicle(\"car\", \"Toyota Camry\");\n    if (car) {\n        car->start();\n        car->stop();\n        cout << \"Vehicle type: \" << car->getType() << endl;\n    }\n    \n    auto motorcycle = VehicleFactory::createVehicle(\"motorcycle\", \"Honda CBR\");\n    if (motorcycle) {\n        motorcycle->start();\n        motorcycle->stop();\n        cout << \"Vehicle type: \" << motorcycle->getType() << endl;\n    }\n    \n    // Factory Method usage\n    cout << \"\\n--- Factory Method ---\" << endl;\n    unique_ptr<VehicleCreator> creator = make_unique<CarCreator>();\n    auto vehicle = creator->createVehicle(\"BMW X5\");\n    if (vehicle) {\n        vehicle->start();\n        vehicle->stop();\n        cout << \"Vehicle type: \" << vehicle->getType() << endl;\n    }\n    \n    // Test unknown type\n    cout << \"\\n--- Testing Unknown Type ---\" << endl;\n    auto unknown = VehicleFactory::createVehicle(\"bicycle\", \"Mountain Bike\");\n    if (!unknown) {\n        cout << \"Failed to create unknown vehicle type\" << endl;\n    }\n    \n    return 0;\n}\n\n/*\nOutput:\n=== Factory Pattern Demo ===\n\n--- Simple Factory ---\nStarting car: Toyota Camry\nStopping car: Toyota Camry\nVehicle type: Car\nStarting motorcycle: Honda CBR\nStopping motorcycle: Honda CBR\nVehicle type: Motorcycle\n\n--- Factory Method ---\nStarting car: BMW X5\nStopping car: BMW X5\nVehicle type: Car\n\n--- Testing Unknown Type ---\nUnknown vehicle type: bicycle\nFailed to create unknown vehicle type\n*/"
  }
]
